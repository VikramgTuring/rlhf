#include <iostream>
#include <string>
#include <regex>

bool containsFormatStringVulnerability(const std::string& code) {
    std::regex dynamic_format_string_regex(R"((sprintf|vsprintf)\s*\([^\)]*\s*,[^\)]*\s*%[^)]*\s*\))");
    std::regex format_string_regex(R"((scanf|printf|fprintf|vfprintf)\s*\([^\)]*%[^)]*\s*\))");
    std::smatch match;
    
    if (std::regex_search(code, match, format_string_regex)) {
        std::cout << "Format string vulnerability detected in the following code: \n" << code << std::endl;
        return true;
    }

    // The following regular expression will flag the 2nd sprintf as the first argument is not a string literal
    if (std::regex_search(code, match, dynamic_format_string_regex)) {
        std::cout << "Potential format string vulnerability due to dynamic string construction: \n" << code << std::endl;
        return true;
    }
    
    return false;
}
    
int main() {
    std::string code1 = "printf(\"Hello, %s!\", name); // Potentially vulnerable";
    std::string code2 = "char format[] = \"%d\"; scanf(format, num);"; // This will be detected
    std::string code3 = "int flag = 1; char format[10]; if (flag) sprintf(format, \"%s\"); printf(format);";
 
    if (containsFormatStringVulnerability(code1)) {
        return 1;
    }
 
    if (containsFormatStringVulnerability(code2)) {
        return 1;
    }
    
    if (containsFormatStringVulnerability(code3)) {
        return 1;
    }
    
    std::cout << "No format string vulnerabilities found." << std::endl;
    return 0;
}

